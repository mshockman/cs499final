## Artifact 3: Databases


For my third artifact I choose to continue improving upon the final project of CS-340.  In CS-340 we learned how to use Mongo and Python to create a simple restful API.  In the original program the user was able to create, read, update and delete stock information via a restful API request.  I choose this project for several reasons.  The first was because this program was already using a database, so it gave me the opportunity to showcase my skills when it comes to creating and maintaining a database. The second was that the idea of a stock tracking application was complex enough that there are multiple features that we can logically add to this type of project.  The third was that there were several glaring flaws in the original project.  In CS-340 the only requirements for the final project was to create an application where the user can create, read, update and delete stock information via a restful API request.  It didn’t ask us to validate the user input or authenticate the user request.  It also didn’t ask us to provide any kind of graphical user interface for the user.  In a “real” project these would be a necessity and the lack of these features provided a good opportunity go showcase my skills by adding them.

The first thing I did to showcase my skills was to migrate the data in the mongo database to Postgres.  To accomplish this, I created the stock table in our Postgres database.  The stock table contains rows of all our stocks and columns for every field that is needed to describe the stock.  The table contains the common fields id, created and last_modified alongside an additional field ticker.  The id field acts as the primary key for the entire table and is an integer that auto increments whenever a new row is inserted.  The created and last_modified columns are timestamps that are automatically set to the current time when the table is either created or updated respectively.  The ticker field is another unique column on the table the acts as a natural key for the stock.  The rest of the columns are optional and provide extra detail to describe the stock.

The next feature that I added to this application was a way to allow the user to categorize stocks.  I also wanted the user to be able to nest categorize inside each other resembling a file structure and stocks should be able to belong to more than one category.  In order to accomplish this, I added two new tables to our database, “category” and “category_stock”.  The “category” table contains meta data about the category itself.  On top of common fields like id, created and last_modifed it contained the fields name, parent_category_id, left and right.  Name should be self-explanatory and describes name of the category.  Parent_category_id is a nullable foreign key field that contains the id of the categories parent if it is not a root node.  Left and right are integers that are used to help optimize the lookups of items in a subcategory.  They are described in the nested set model and are a common way to handle hierarchical data in a relational database.  Finally, the category_stock table is simply an association table that associates stocks to their categories.  It contains the standard columns and foreign keys to both the stock and category.

Finally, I added user authentication to the project.  This feature required a brand-new table to store user account information.  The table contains the user’s email, first name, last name, and their password.  The password is stored as a one way has using bcrypt and is salted.  The password is stored in the format password_hash + salt.  Salts are extra randomly generated characters that are appended to the end of the password.  Salts ensure that two users with the same password don’t have the same hash in the database.  This helps prevent rainbow table lookups if the database was ever exposed to hackers.  The security of this table is one of the most important as it is common for people to use the same login credentials across multiple sites.

The biggest challenge that I faced when improving this software was implanting the nested set model.  I had to create helper functions in python to handle the common tasks of inserting and deleting categories because extra care needs to be made to ensure that the left and the right columns don’t fall out of sync.  Anther aspect that was extremely interesting to research was how to securely store passwords in a database.  I already knew previously that it was a bad idea to store passwords in a database as raw text, but I never thought about the idea of salting the passwords before encrypting.  Now that I’ve read about them it makes perfect sense as otherwise you would just need to do a join against common passwords to break into a lot of peoples accounts.

---

Citations
Nested Set Model: the best approach to deal with hierarchical data. (2017). Coderwall. Retrieved 29 July 2019, from https://coderwall.com/p/ohomlg/nested-set-model-the-best-approach-to-deal-with-hierarchical-data
---

- [Self Assessment](index.md)
- [Artifact 1](artifact1.md)
- [Artifact 2](artifact2.md)